<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>mysql批量插入效率初步研究及批量测试数据生成方式 | 程序猿的一生</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前话这个其实是大三的时候老师给的一个学年论文的题目，也好好研究了一下，去除一些套话，就push上来吧。可能有不够严谨的地方，请多包涵，哈哈。前面主要就是对mysql的存储过程简单的运用了一下，后面测试主要语言是java。
引用别人的一句话一般来说，硬件环境里起主要作用的是数据库主机，它是存取数据的地方。那么影响数据库性能的关键主要有IO性能和CPU性能。IO性能包括每秒可提供的IO访问次数和每秒的">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql批量插入效率初步研究及批量测试数据生成方式">
<meta property="og:url" content="http://yoursite.com/2015/05/12/mysql批量插入效率初步研究及批量测试数据生成方式/index.html">
<meta property="og:site_name" content="程序猿的一生">
<meta property="og:description" content="前话这个其实是大三的时候老师给的一个学年论文的题目，也好好研究了一下，去除一些套话，就push上来吧。可能有不够严谨的地方，请多包涵，哈哈。前面主要就是对mysql的存储过程简单的运用了一下，后面测试主要语言是java。
引用别人的一句话一般来说，硬件环境里起主要作用的是数据库主机，它是存取数据的地方。那么影响数据库性能的关键主要有IO性能和CPU性能。IO性能包括每秒可提供的IO访问次数和每秒的">
<meta property="og:image" content="images/yw02001.png">
<meta property="og:image" content="images/yw02002.png">
<meta property="og:image" content="images/yw02003.png">
<meta property="og:image" content="images/yw02004.jpg">
<meta property="og:image" content="images/yw02005.jpg">
<meta property="og:image" content="images/yw02006.jpg">
<meta property="og:image" content="images/yw02006.png">
<meta property="og:image" content="images/yw02007.png">
<meta property="og:image" content="images/yw02009.png">
<meta property="og:image" content="images/yw02010.png">
<meta property="og:image" content="images/yw02011.jpg">
<meta property="og:image" content="images/yw02012.jpg">
<meta property="og:image" content="images/yw02013.png">
<meta property="og:image" content="images/yw02014.png">
<meta property="og:image" content="images/yw02015.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mysql批量插入效率初步研究及批量测试数据生成方式">
<meta name="twitter:description" content="前话这个其实是大三的时候老师给的一个学年论文的题目，也好好研究了一下，去除一些套话，就push上来吧。可能有不够严谨的地方，请多包涵，哈哈。前面主要就是对mysql的存储过程简单的运用了一下，后面测试主要语言是java。
引用别人的一句话一般来说，硬件环境里起主要作用的是数据库主机，它是存取数据的地方。那么影响数据库性能的关键主要有IO性能和CPU性能。IO性能包括每秒可提供的IO访问次数和每秒的">
  
    <link rel="alternative" href="/atom.xml" title="程序猿的一生" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">程序猿的一生</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-mysql批量插入效率初步研究及批量测试数据生成方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/12/mysql批量插入效率初步研究及批量测试数据生成方式/" class="article-date">
  <time datetime="2015-05-12T12:35:12.000Z" itemprop="datePublished">2015-05-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/运维-数据库/">运维,数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      mysql批量插入效率初步研究及批量测试数据生成方式
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前话">前话</h2><p>这个其实是大三的时候老师给的一个学年论文的题目，也好好研究了一下，去除一些套话，就push上来吧。可能有不够严谨的地方，请多包涵，哈哈。前面主要就是对mysql的存储过程简单的运用了一下，后面测试主要语言是java。</p>
<h2 id="引用别人的一句话">引用别人的一句话</h2><p>一般来说，硬件环境里起主要作用的是数据库主机，它是存取数据的地方。那么影响数据库性能的关键主要有IO性能和CPU性能。IO性能包括每秒可提供的IO访问次数和每秒的IO总流量.CPU的性能主要关系到处理的请求以及处理并发以及计算。所以IO和CPU的性能提升都可以提升数据库系统的性能。<br>所以一般来说，就从这两方面下手，去寻求一个平衡。</p>
<h2 id="测试数据表的生成">测试数据表的生成</h2><p>首先新建一个测试数据表。表名为user，字段为id,name,age,datetime。接下面在MySQL中写建表代码。  </p>
<p>建表代码：  </p>
<pre><code><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (
  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,
  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,
  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,
  <span class="string">`datetime`</span> <span class="keyword">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0000-00-00 00:00:00'</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,
  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`id`</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE
)  </span>
</code></pre><p>下面查看一下在MySQL里的表生成情况。<br><img src="images/yw02001.png" alt="数据库详情"> </p>
<h2 id="普通方法生成测试数据研究分析">普通方法生成测试数据研究分析</h2><p>传统的方法，即使用每次插入一条记录的方式，插入十万条数据。下面将通过MySQL的存储过程来随机生成测试数据，存储过程代码如下。  </p>
<p>存储过程：  </p>
<pre><code>drop <span class="function"><span class="keyword">procedure</span> <span class="title">if</span> <span class="title">exists</span> <span class="title">loopUserInsert</span>;</span>
Delimiter $$
<span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">loopUserInsert</span><span class="params">(<span class="keyword">in</span> amount int)</span>
<span class="title">begin</span>
<span class="title">declare</span> <span class="title">a</span> <span class="title">int</span>;</span>
<span class="keyword">set</span> a = <span class="number">1</span>;
<span class="keyword">while</span> a&lt;=amount <span class="keyword">do</span>
Insert <span class="keyword">into</span> user (name,age,datetime) 
values (<span class="keyword">concat</span>(<span class="string">'user'</span>,(a+<span class="number">1</span>)),ceil(<span class="number">100</span>*rand()),now());
<span class="keyword">set</span> a = a+<span class="number">1</span>;
<span class="keyword">end</span> <span class="keyword">while</span>;
<span class="keyword">end</span>$$  
</code></pre><p>在MySQL中生成存储过程后，用call loopUserInsert(100000);来执行存储过程插入100000条数据。普通方法插入10万条数据结果如下。<br><img src="images/yw02002.png" alt="数据库情况"><br><img src="images/yw02003.png" alt="数据库情况">   </p>
<p>由于是最为普通的循环插入方法，且为逐条插入，因此效率很低是显而易见的，在等待漫长的执行过程后，查询结果，从图来看，第一条语句是2013-09-16 15:34:54插入的，而从图可以看出最后一条语句是2013-09-16 15:53:54插入的。<strong>这个插入10万条的存储过程花费了将近20分钟才执行完</strong>。由此可见，<strong>传统的方法插入时，每插入一条即做了一次IO，所以这消耗了大量的资源，效率非常的低</strong>。更不用说一次性插入50万条甚至百万级数据的情况了。</p>
<h2 id="一次性批量生成测试数据研究分析">一次性批量生成测试数据研究分析</h2><p>这一次将同样用存储过程，用批量插入的方法插入10万条数据。首先用<code>truncate table user;</code>清空整个表。然后重新修改编写存储过程。  </p>
<p>修改后的存储过程：    </p>
<pre><code>drop procedure <span class="keyword">if</span> exists loopUserAllInsert;
delimiter <span class="variable">$$</span>
create procedure loopUserAllInsert(<span class="keyword">in</span> amount int)
<span class="keyword">begin</span>
declare i int;
set i = <span class="number">1</span>;
set <span class="variable">@sqltext</span> = <span class="string">'insert into user (name,age,datetime) values '</span>;
<span class="keyword">while</span> i&lt;=amount <span class="keyword">do</span>
<span class="keyword">if</span> i&lt;amount <span class="keyword">then</span>
set <span class="variable">@sqltext</span> 
= concat(<span class="variable">@sqltext</span>,<span class="string">"('"</span>,concat(<span class="string">'user'</span>,i),<span class="string">"',"</span>,ceil(<span class="number">100</span>*rand()),<span class="string">",'"</span>,now(),<span class="string">"'),"</span>);
elseif i=
amount <span class="keyword">then</span> set <span class="variable">@sqltext</span>
= concat(<span class="variable">@sqltext</span>,<span class="string">"('"</span>,concat(<span class="string">'user'</span>,i),<span class="string">"',"</span>,ceil(<span class="number">100</span>*rand()),<span class="string">",'"</span>,now(),<span class="string">"')"</span>);
<span class="keyword">end</span> <span class="keyword">if</span>;
set i = i+<span class="number">1</span>;
<span class="keyword">end</span> <span class="keyword">while</span>;
prepare stmt from <span class="variable">@sqltext</span>;
execute stmt;
deallocate prepare stmt;
<span class="keyword">end</span><span class="variable">$$</span>
</code></pre><p>在MySQL中生成存储过程后，用call loopUserAllInsert(100000);来执行存储过程插入100000条数据。<br>当调用插入100000条的存储过程时，MySQL报出了一个错误，存储过程没能成功执行。而尝试call loopUserAllInsert(20000)，却可以成功。在研究分析后，得出是因为mysql max_allowed_packet 设置过小导致记录写入失败。<br>解决方法：先用<code>show VARIABLES like &#39;%max_allowed_packet%&#39;;</code>来查询目前此变量的大小。然后通过<code>set global max_allowed_packet = 1024*1024*10;</code>来把变量设置为10M。操作结果如下图。<br><img src="images/yw02004.jpg" alt="数据库情况"> </p>
<p>在修改完max_allowed_packet后，试着重新调用之前未执行成功的一次性插入十万条的存储过程call loopUserAllInsert(100000)，执行成功。这次以同样的方法查询结果。可以由图得知第一条插入的时间为2013-09-19 13:39:14，而第十万条记录插入的时间为 2013-09-19 13:44:30，这样计算执行时间为5分16秒。<code>与insertUserInsert此存储过程执行的时间相比，节省了15分钟。由每分钟插入5000条记录提高到了每分钟插入20000条。效率上是之前的四倍之多。</code></p>
<p>结果图如下：<br><img src="images/yw02005.jpg" alt="数据库情况"><br><img src="images/yw02006.jpg" alt="数据库情况"></p>
<p>虽然该方法比第一种方法效率提高了很多，但是这样一次性插入主用是用的CPU的性能，而IO性能相对第一种方法就用的少了很多（第一种方法IO占用很多，CPU占用相反很少）。<strong>那么可否想一种结合CPU和IO的方法？在接下来的方法中，将仍然采用批量插入的方法，但是一次只插入2000条或者5000条。预计测试结果会比第一种方法和第二种方法都提高一些，是否是这样呢，准备开始第三种方法的尝试！</strong></p>
<h2 id="分批批量生成测试数据研究分析">分批批量生成测试数据研究分析</h2><p>这一次将结合前两种方法，分多批次插入，每次批量插入2000条记录。这样让CPU和IO性能找到平衡。首先依然用truncate table user;清空整个表。然后修改编写存储过程。  </p>
<p>存储过程如下：  </p>
<pre><code>create procedure loopUserInsert_batch(<span class="keyword">in</span> amount <span class="built_in">int</span>)
begin
declare i <span class="built_in">int</span>;
<span class="literal">set</span> i = <span class="number">1</span>;
<span class="keyword">while</span> i &lt;= amount <span class="keyword">do</span>
<span class="keyword">if</span> mod(i,<span class="number">2000</span>) = <span class="number">1</span> then
<span class="literal">set</span> <span class="annotation">@sqltext</span> = concat(<span class="string">"('"</span>,concat(<span class="string">"user"</span>,i),<span class="string">"',"</span>,ceil(<span class="number">100</span>*rand()),<span class="string">",'"</span>,now(),<span class="string">"'),"</span>);
elseif mod(i,<span class="number">2000</span>)=<span class="number">0</span> then
<span class="literal">set</span><span class="annotation">@sqltext</span>=concat(<span class="annotation">@sqltext</span>,<span class="string">"('"</span>,concat(<span class="string">"user"</span>,i),<span class="string">"',"</span>,ceil(<span class="number">100</span>*rand()),<span class="string">",'"</span>,now(),<span class="string">"')"</span>);
<span class="literal">set</span> <span class="annotation">@sqltext</span>=concat( <span class="string">'insert into user (name,age,datetime) values '</span>,<span class="annotation">@sqltext</span> );
prepare stmt from <span class="annotation">@sqltext</span>;
execute stmt;
DEALLOCATE PREPARE stmt;
<span class="literal">set</span> <span class="annotation">@sqltext</span>=<span class="string">''</span>;
<span class="keyword">else</span>
<span class="literal">set</span><span class="annotation">@sqltext</span>=concat(<span class="annotation">@sqltext</span>,<span class="string">"('"</span>,concat(<span class="string">"user"</span>,i),<span class="string">"',"</span>,ceil(<span class="number">100</span>*rand()),<span class="string">",'"</span>,now(),<span class="string">"'),"</span>);
end <span class="keyword">if</span>;
<span class="literal">set</span> i = i+<span class="number">1</span>;
end <span class="keyword">while</span>;
<span class="keyword">if</span> <span class="annotation">@sqltext</span>&lt;&gt;<span class="string">''</span> then
<span class="literal">set</span> <span class="annotation">@sqltext</span> = trim(trailing <span class="string">","</span> from <span class="annotation">@sqltext</span>);
<span class="literal">set</span> <span class="annotation">@sqltext</span> = concat(<span class="string">'insert into user (name,age,datetime) values '</span>,<span class="annotation">@sqltext</span>);
prepare stmt from <span class="annotation">@sqltext</span>;
execute stmt;
DEALLOCATE PREPARE stmt;
<span class="literal">set</span> <span class="annotation">@sqltext</span>=<span class="string">''</span>;
end <span class="keyword">if</span>;
end $$  
</code></pre><p>在MySQL中生成存储过程后，依然用call loopUserInsert_batch(100000);来执行存储过程插入100000条数据。<br>结果图如下：<br><img src="images/yw02006.png" alt="数据库情况"><br><img src="images/yw02007.png" alt="数据库情况"><br>这次执行完成得很快，可以看到在datetime这一列中，第一条记录的插入时间是2013-09-20 16:07:27。最后一条插入的时间是2013-09-20 16:07:32。  </p>
<p>计算后可知，<strong>本次用loopUserInsert_batch存储过程插入10万条数据，仅仅只花了5秒钟！相比较与第一种方法的20分钟与第二种方法的5分钟，这简直就是几何级增长！相当于把平均每分钟插入2万条记录提高到了每分钟120万条记录</strong>。<br>使用该存储过程插入50万条测试数据时，结果如下图。可以看出第一条记录插入时间是2013-09-20 19:30:30，第50万条记录的插入时间是2013-09-20 19:30:56。由此可知，插入50万条数据用了26秒。推算到120万条数据，大约是1分钟。正好验证了之前的推论。  </p>
<p><img src="images/yw02009.png" alt="数据库情况"><br><img src="images/yw02010.png" alt="数据库情况">  </p>
<p>在初步的研究成果得到验证后，试想能否继续提升数据的插入速度呢？<strong>下面对loopUserInsert_batch存储方法进行进一步修改，把每条insert语句固定插入2000条记录修改为自定义方式。</strong>以便于更好的测试最佳方法。  </p>
<p>修改后的存储过程如下：  </p>
<pre><code>delimiter $$
create procedure loopUserInsert_customBatch(<span class="keyword">in</span> amount <span class="built_in">int</span>,<span class="keyword">in</span> custom <span class="built_in">int</span>)
begin
declare i <span class="built_in">int</span>;
<span class="literal">set</span> i = <span class="number">1</span>;
<span class="keyword">while</span> i &lt;= amount <span class="keyword">do</span>
<span class="keyword">if</span> mod(i,custom) = <span class="number">1</span> then
<span class="literal">set</span> <span class="annotation">@sqltext</span> = concat(<span class="string">"('"</span>,concat(<span class="string">"user"</span>,i),<span class="string">"',"</span>,ceil(<span class="number">100</span>*rand()),<span class="string">",'"</span>,now(),<span class="string">"'),"</span>);
elseif mod(i,custom)=<span class="number">0</span> then
<span class="literal">set</span><span class="annotation">@sqltext</span>=concat(<span class="annotation">@sqltext</span>,<span class="string">"('"</span>,concat(<span class="string">"user"</span>,i),<span class="string">"',"</span>,ceil(<span class="number">100</span>*rand()),<span class="string">",'"</span>,now(),<span class="string">"')"</span>);
<span class="literal">set</span> <span class="annotation">@sqltext</span>=concat( <span class="string">'insert into user (name,age,datetime) values '</span>,<span class="annotation">@sqltext</span> );
prepare stmt from <span class="annotation">@sqltext</span>;
execute stmt;
DEALLOCATE PREPARE stmt;
<span class="literal">set</span> <span class="annotation">@sqltext</span>=<span class="string">''</span>;
<span class="keyword">else</span>
<span class="literal">set</span><span class="annotation">@sqltext</span>=concat(<span class="annotation">@sqltext</span>,<span class="string">"('"</span>,concat(<span class="string">"user"</span>,i),<span class="string">"',"</span>,ceil(<span class="number">100</span>*rand()),<span class="string">",'"</span>,now(),<span class="string">"'),"</span>);
end <span class="keyword">if</span>;
<span class="literal">set</span> i = i+<span class="number">1</span>;
end <span class="keyword">while</span>;
<span class="keyword">if</span> <span class="annotation">@sqltext</span>&lt;&gt;<span class="string">''</span> then
<span class="literal">set</span> <span class="annotation">@sqltext</span> = trim(trailing <span class="string">","</span> from <span class="annotation">@sqltext</span>);
<span class="literal">set</span> <span class="annotation">@sqltext</span> = concat(<span class="string">'insert into user (name,age,datetime) values '</span>,<span class="annotation">@sqltext</span>);
prepare stmt from <span class="annotation">@sqltext</span>;
execute stmt;
DEALLOCATE PREPARE stmt;
<span class="literal">set</span> <span class="annotation">@sqltext</span>=<span class="string">''</span>;
end <span class="keyword">if</span>;
end $$  
</code></pre><p>在所修改了自定义参数的存储过程在数据库中保存以后，即可以用call loopUserInsert_customBatch(amount,custom)来调用存储过程进行测试。amount，custom可以自定义数量。在一系列测试以后，<strong>发现把每次插入的数量custom设置为5000时，插入50万记录为30秒以上；设置为1000左右的时候，接近30秒；而设置为2000左右比较合适，执行结果为24秒</strong>。这个结果同该测试环境的IO性能和CPU性能有关，若采用配置更高的环境，速度则更快。  </p>
<p>以上为mysql存储过程部分的讨论，下面就是结合java来讨论下插入大量数据时，连接池，存储过程以及使用批量处理的时间比较。由于今天再看这篇文章发现，比较时不变量没有控制好，只截取部分比较。</p>
<h2 id="JAVA中批处理对性能的影响">JAVA中批处理对性能的影响</h2><p>一般来说，JAVA向数据库提交大量数据时，往往会花费大量的时间。但是如果使用批处理进行提交数据，即执行批量插入数据库，而不是一条INSERT语句就向数据库提交一次，这样会提高效率，节省大量时间。接下来，用普通插入方式和批处理方式来测试一个插入10万条数据的例子，来验证这个结论。   </p>
<p>首先使用普通插入方式，JAVA代码如下：  </p>
<pre><code><span class="keyword">public</span> <span class="keyword">void</span> notUseBatchInsert(<span class="built_in">int</span> amount, <span class="built_in">int</span> custom) {
    Connection conn = DBFactory.INSTANCE.getConnection();
    <span class="keyword">String</span> sql = <span class="string">"insert into user (name,age,datetime) values (?,?,?)"</span>;
    <span class="keyword">try</span> {
        SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);<span class="comment">// 设置日期格式</span>
        PreparedStatement ps = conn.prepareStatement(sql);
        conn.setAutoCommit(<span class="keyword">false</span>);
        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++) {
            ps.setString(<span class="number">1</span>, <span class="string">"user"</span> + i);
            ps.setInt(<span class="number">2</span>, (<span class="built_in">int</span>) (Math.<span class="built_in">random</span>() * <span class="number">100</span>));
            ps.setString(<span class="number">3</span>, df.format(<span class="keyword">new</span> Date()));
            ps.executeUpdate();
            conn.commit();
        }
    } <span class="keyword">catch</span> (SQLException e) {
        <span class="comment">// TODO Auto-generated catch block</span>
        e.printStackTrace();
    } <span class="keyword">finally</span> {
        DBFactory.INSTANCE.closeConnection(conn);
    }
}
</code></pre><p>用servlet调用该方法，代码与以下servlet方法类似，<br>通过servlet的以下代码调用该方法：  </p>
<pre><code><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> throws ServletException, IOException </span>{
        SqlMethodsDao sqlMethods = <span class="keyword">new</span> SqlMethodsDao();
        System.<span class="keyword">out</span>.println(<span class="string">"开始时间"</span> + <span class="keyword">new</span> Date());
        sqlMethods.copyTable_NoPool();
        System.<span class="keyword">out</span>.println(<span class="string">"结束时间"</span> + <span class="keyword">new</span> Date());        
    }
</code></pre><p>主要调用代码为sqlMethods.notUseBatchInsert(100000)。结果如下图：<br><img src="images/yw02011.jpg" alt="结果"></p>
<p>现在再使用批处理方式，JAVA代码如下：  </p>
<pre><code><span class="keyword">public</span> <span class="keyword">void</span> useBatchInsert(<span class="built_in">int</span> amount){
        Connection conn = DBFactory.INSTANCE.getConnection();
        <span class="keyword">String</span> sql = <span class="string">"insert into user (name,age,datetime) values (?,?,?)"</span>;
         <span class="keyword">try</span> {
             SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);<span class="comment">//设置日期格式</span>
             PreparedStatement ps  = conn.prepareStatement(sql);
            conn.setAutoCommit(<span class="keyword">false</span>);
            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; amount+<span class="number">1</span>; i++) {
                ps.setString(<span class="number">1</span>, <span class="string">"user"</span>+i);
                ps.setInt(<span class="number">2</span>, (<span class="built_in">int</span>) (Math.<span class="built_in">random</span>()*<span class="number">100</span>));
                ps.setString(<span class="number">3</span>, df.format(<span class="keyword">new</span> Date()));
                ps.addBatch();
                <span class="keyword">if</span> (i%custom == <span class="number">0</span> || i==amount) {
                    ps.executeBatch();
                    conn.commit();
                }
            }        
        } <span class="keyword">catch</span> (SQLException e) {
            <span class="comment">// TODO Auto-generated catch block</span>
            e.printStackTrace();
        }<span class="keyword">finally</span>{
            DBFactory.INSTANCE.closeConnection(conn);
        }
    }
</code></pre><p>现在清空user表后，同样使用servlet调用该方法，主要的方法调用代码为sqlMethods.useBatchInsert(100000, 2000)。执行的结果明显快了很多，结果详情如下图：<br><img src="images/yw02012.jpg" alt="结果"><br>由图4-3和4-4可知，在向同一个数据表中插入十万数据时，不使用批处理的情况下需要花费19分33秒，而使用了批量处理之后，仅仅只需要27秒的时间。为了让结论更加清晰，把数据量提升到30万和50万进行多次测试，结果如下表。<br><img src="images/yw02013.png" alt="结果"><br>由表4-2可以得出，使用批处理来处理大批量数据明显比不使用批处理效率高非常多。而且数据量越大，所节省的时间越多。所以在JAVA中使用批处理来处理大量数据是非常好的选择。</p>
<h2 id="存储过程对性能的影响">存储过程对性能的影响</h2><p><strong>这一段选取的例子不够好，对存储过程的作用没体现出来。</strong><br>存储过程是由一些SQL语句和控制语句组成的被封装起来的过程，它驻留在数据库中，可以被客户应用程序调用，也可以从另一个过程或触发器调用。<br>存储过程有什么好处呢？ 在存储过程创建的时候，数据库已经对其进行了一次解析和优化。其次，存储过程一旦执行，在内存中就会保留一份这个存储过程，这样下次再执行同样的存储过程时，可以从内存中直接调用。 所以执行速度更快。<br>下面将使用4.1中的例子来测试使用存储过程的情况和不使用存储过程的情况。也就是新建一个数据表user_copy，然后从先前所建立的测试表user（50万数据）中选取id,name,datetime字段复制记录到user_copy表。通过servlet来调用方法。<br>不使用存储过程代码为：   </p>
<pre><code>public void copyTable_NoPool() {
        <span class="built_in">String</span> sql = <span class="string">"insert into user_copy(id,name,datetime) select id,name,datetime from user"</span>;
        <span class="keyword">try</span> {
            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);
            Connection conn = DriverManager
.getConnection(<span class="string">"jdbc:mysql://localhost/test?useUnicode=true&amp;characterEncoding=UTF-8"</span>);
            PreparedStatement ps = conn.prepareStatement(sql);
            ps.executeUpdate();    
            conn.close();
        } <span class="keyword">catch</span> (<span class="built_in">Exception</span> <span class="literal">e</span>) {
            <span class="literal">e</span>.printStackTrace();
        }
    }
</code></pre><p>主要分析下使用存储过程的代码，代码如下。<br>存储过程代码：  </p>
<pre><code>Delimiter $$
<span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">copyTable</span><span class="params">()</span>
<span class="title">begin</span>
<span class="title">insert</span> <span class="title">into</span> <span class="title">user_copy</span><span class="params">(id,name,datetime)</span> <span class="title">select</span> <span class="title">id</span>,<span class="title">name</span>,<span class="title">datetime</span> <span class="title">from</span> <span class="title">user</span>;</span>
<span class="keyword">end</span>$$
</code></pre><p>JAVA调用存储过程代码：  </p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">copyTablePro</span><span class="params">()</span> </span>{
        Connection conn = DBFactory.INSTANCE.getConnection();
        CallableStatement cs = <span class="keyword">null</span>;
        <span class="keyword">try</span> {
            cs = conn.prepareCall(<span class="string">"{call copyTable()}"</span>);
            cs.execute();
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        } <span class="keyword">finally</span> {
            DBFactory.INSTANCE.closeConnection(conn);
        }
    }
</code></pre><p>使用已写好的servlet调用该方法，sqlMethods.copyTablePro()。结果如下表。<br><img src="images/yw02014.png" alt="结果"><br>可以得出，该例子使用存储过程比不使用存储过程略微快一些，数据越多，使用存储过程越快。由于该例子的存储过程代码执行代码较少，效率提升并不是很明显。在下面的综合比较中，将展示存储过程强大的优势。  </p>
<h2 id="综合比较">综合比较</h2><p>接下来，将做一个向user表插入50万数据的对比。对比项为批处理+连接池与存储过程+连接池。<br>批处理+连接池的代码在前文中的批处理部分。<br>连接池+存储过程调用代码：  </p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">excuteProcedure</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span> custom)</span> </span>{
        Connection conn = <span class="keyword">null</span>;
        conn = DBFactory.INSTANCE.getConnection();
        CallableStatement cs = <span class="keyword">null</span>;
        <span class="keyword">try</span> {
            cs = conn.prepareCall(<span class="string">"{call loopUserInsert_customBatch(?,?)}"</span>);
            cs.setInt(<span class="number">1</span>, amount);
            cs.setInt(<span class="number">2</span>, custom);            
            cs.execute();        
        } <span class="keyword">catch</span> (Exception e) {
            <span class="comment">// TODO: handle exception</span>
        } <span class="keyword">finally</span> {
            DBFactory.INSTANCE.closeConnection(conn);
        }
    }
</code></pre><p>存储过程具体代码前文中的loopUserInsert_customBatch方法。保证每次都是处理2000条，最后结果如表。<br><img src="images/yw02015.png" alt="结果"> </p>
<h2 id="结束">结束</h2><p>大三拿到任务，当时水平有限，专研不深，不过还是用心做了一下的。现在都木有这么多时间去专门研究一个问题。怀念大学！继续加油！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/12/mysql批量插入效率初步研究及批量测试数据生成方式/" data-id="ciaxaq130000g2smc21hl77uj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/">mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/运维/">运维</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/05/12/内网服务器暴露到外网/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          内网服务器暴露到外网（linux下的Apache2端口修改）
        
      </div>
    </a>
  
  
    <a href="/2015/05/11/hexo搭建/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hexo博客的搭建</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/github/">github</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维-数据库/">运维,数据库</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/路由器/">路由器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/运维/">运维</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/git/" style="font-size: 10px;">git</a><a href="/tags/github/" style="font-size: 10px;">github</a><a href="/tags/hexo/" style="font-size: 10px;">hexo</a><a href="/tags/mysql/" style="font-size: 10px;">mysql</a><a href="/tags/数据库/" style="font-size: 10px;">数据库</a><a href="/tags/路由器/" style="font-size: 10px;">路由器</a><a href="/tags/运维/" style="font-size: 20px;">运维</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/05/12/内网服务器暴露到外网/">内网服务器暴露到外网（linux下的Apache2端口修改）</a>
          </li>
        
          <li>
            <a href="/2015/05/12/mysql批量插入效率初步研究及批量测试数据生成方式/">mysql批量插入效率初步研究及批量测试数据生成方式</a>
          </li>
        
          <li>
            <a href="/2015/05/11/hexo搭建/">Hexo博客的搭建</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 吴寒<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>